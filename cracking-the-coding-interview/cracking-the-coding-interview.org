
#+TITLE: Hacker Rank: Cracking the Coding Interview
#+AUTHOR: Martín Alsinet
#+DATE: 2017
#+OPTIONS: toc:nil ':t num:nil
#+LANGUAGE: en
#+LaTeX_HEADER: \usemintedstyle{default}
#+LaTeX_HEADER: \usepackage{xcolor}
#+LaTeX_HEADER: \definecolor{bg}{rgb}{0.95,0.95,0.95}

* Introduction

I am using the challenges from /HackerRank: Cracking the Coding Interview/ to practice some fundamental computer science concepts using different programming languages.

Initially I will use Javascript and Python, writing solutions for each challenge in both languages. I will try to add some other programming languages later.

* Setup
** Javascript Setup
*** Package.json

#+BEGIN_SRC js :tangle package.json
{
  "name": "hackerrank-coding-interview",
  "version": "0.1.0",
  "description": "Hacker Rank: Cracking the Coding Interview",
  "main": "index.js",
  "scripts": {
    "start": "npm start"
  },
  "author": "Martín Alsinet",
  "license": "CC",
}
#+END_SRC

** Python Setup
* Test Cases

Each challenge comes with a set of test cases that must be successfully run in order to verify that the proposed solution for the challenge is correct. These test cases consist in a set of files with input data and its expected output when processed by a correct solution. They are simple .txt files which I have downloaded into the =./testcases/= folder. Their filename format is =inputXX.txt= and =outputXX.txt=, where the =XX= is the test case number.

We need a test case runner that can read each input file, run the test case using my proposed solution, and compare the output of the execution of that test case to the corresponding output file. If both outputs are equal, the function passes the test case. It would also be nice to be able to measure the time taken for each test case run and its resource usage.

*** TODO Modify to tar.gzip test cases

The test cases for just the first exercise require 2.5 MB. There are 20 challenges in total, so the entire set of test cases for all challenges will require at least 50 MB. It could be useful to compress all those text files and decompress them on demand when we are running a test case.

** Javascript test case runner

The following source code block will be referenced from all Javascript solutions in order to run the suite of test cases corresponding to that challenge. It creates an object called =tc= with the following methods:

- list :: List the available test cases in a folder with their input and output files
- run :: Execute a specific test case providing a solution function
- suite :: Execute the complete test case suite
- results :: Return a summary array with the results of a test suite run

#+NAME: js-testcase
#+BEGIN_SRC js
var fs = require('fs');
var path = require('path');

var tc = {
    list: function(folder){
        var files = fs.readdirSync(folder);
        var inputs = files.filter(filename => filename.startsWith("input"));
        var outputs = files.filter(filename => filename.startsWith("output"));
        var testcases = inputs.map(function (item, i) { 
            return {
                input: path.join(folder, item), 
                output: path.join(folder, outputs[i])
            } 
        });
        return testcases;
    },
    run: function(testcase, runFn){
        var input = fs.readFileSync(testcase.input, "utf8");
        var begin = Date.now();
        var result = runFn(input.split("\n"));
        var end = Date.now();
        var expected = fs.readFileSync(testcase.output, "utf8");
        return {
             success: (expected === result),
             runtime: (end-begin) + " msec",
              result: result,
            expected: expected
        }
    },
    suite: function(testcases, fn){
        var that = this;
        return testcases.map(
            function(testcase, i) {
                var tc = that.run(testcase, fn);
                return {
                    testcase: i+1,
                     success: tc.success,
                     runtime: tc.runtime
                };
            });
    },
    results: function(tests){
        var titles = ["Test case", "Success", "Runtime"];
        var results = tests.map(
            function(test){
                return [test.testcase, test.success, test.runtime]
            }
        );
        results.unshift(titles);
        return results;
    }
}
#+END_SRC

** Python test case runner

In this case, I am going to replicate much of the logic I already did in Javascript for the Python version of the test case runner.

#+NAME: py-testcase
#+BEGIN_SRC python

import os
from timeit import default_timer as timer
from math import ceil

def merge(d1, d2):
    ''' Merge two dictionaries. '''
    merged = {}
    merged.update(d1)
    merged.update(d2)
    return merged

def filenames(prefix, folder):
    return [{prefix: os.path.join(folder, file)} 
        for file in os.listdir(folder) 
            if file.startswith(prefix)]

def elapsed_str(end, start):
    return str(int(round((end-start)*1000)))+" msec"

class TestCase:
    def __init__(self, folder):
        self.folder = folder

    def list(self):
        inputs  = filenames("input", self.folder)
        outputs = filenames("output", self.folder)
        return [merge(i,o) for i,o in list(zip(inputs, outputs))]

    def run(self, testcase, fn):
        with open(testcase["input"]) as inf, open(testcase["output"]) as outf:
            input_text = inf.read()
            start = timer()
            result = " ".join(str(x) for x in fn(input_text.split("\n")))
            end = timer()
            expected_text = outf.read()
            return {
                "success": (result == expected_text),
                "runtime": elapsed_str(end, start),
                "result": result,
                "expected": expected_text
            }

    def suite(self, testcases, fn):
        return [self.fields(self.run(test, fn)) for test in testcases]

    def results(self, tests):
        titles = [["Test case", "Success", "Runtime"]]
        results = [[i+1, t["success"], t["runtime"]] for i, t in enumerate(tests)]
        return titles + results

    def fields(self, item):
        return {
            "success": item["success"],
            "runtime": item["runtime"]
        }

#+END_SRC

#+RESULTS: py-testcase
: None

* Data Structures
** Arrays: Left Rotation
*** Problem Definition

A left rotation operation on an array of size /*n*/ shifts each of the array's elements 1 unit to the left. For example, if 2 left rotations are performed on array [1, 2, 3, 4, 5], then the array would become [3, 4, 5, 1, 2].

Given an array of /*n*/ integers and a number, /*d*/, perform /*d*/ left rotations on the array. Then print the updated array as a single line of space-separated integers.

*** Input Format

The first line contains two space-separated integers denoting the respective values of /*n*/ (the number of integers) and /*d*/ (the number of left rotations you must perform). The second line contains /*n*/ space-separated integers describing the respective elements of the array's initial state.

*** Constraints

- 1 \le /*n*/ \le 10^5
- 1 \le /*d*/ \le /*n*/
- 1 \le /*a_i*/ \le 10^6

*** Output Format

Print a single line of /*n*/ space-separated integers denoting the final state of the array after performing /*d*/ left rotations.

**** Sample Input

#+BEGIN_SRC sh :eval never
5 4
1 2 3 4 5
#+END_SRC

**** Sample Output

#+BEGIN_SRC sh :eval never
5 1 2 3 4
#+END_SRC

*** Explanation

When we perform ~d = 4~ left rotations, the array undergoes the following sequence of changes:

#+BEGIN_QUOTE
[1, 2, 3, 4, 5] \rarr [2, 3, 4, 5, 1] \rarr [3, 4, 5, 1, 2] \rarr [4, 5, 1, 2, 3] \rarr [5, 1, 2, 3, 4]
#+END_QUOTE

Thus, we print the array's final state as a single line of space-separated values, which is =5 1 2 3 4=.

*** Solutions
**** Javascript

*Naive solution*

My first approach to the solution uses a temporary array (=ret=) to store the array to be returned. Since I have to perform *k* left rotations, that means that the first element of the result array will be in the *k* position in the source array. So, we start in the *k* position and push all remaining elements into the result array (from index *k* until *n-1*). Then, we append the elements starting from the beginning of the source array until reaching the *k-1* position so that we have all elements in the result array (from index *0* until *k-1*).

#+NAME: Naive solution
#+BEGIN_SRC js  :noweb yes
<<js-testcase>>

function challenge_solution(lines) {
    var n_temp = lines[0].split(' ');
    var n = parseInt(n_temp[0]);
    var k = parseInt(n_temp[1]);
    var a = lines[1].split(" ");;
    return left_rotate(n, k, a).join(" ");
}
function left_rotate(n, k, a) {
    ret = [];
    for (var i=k; i<n; i++) {
        ret.push(a[i]);
    }
    for (var j=0; j<k; j++) {
        ret.push(a[j]);
    }
    return ret;
}

var folder = "./testcases/arrays-left-rotation";
return tc.results(
    tc.suite(
        tc.list(folder), challenge_solution
    )
);

#+END_SRC

#+RESULTS: Naive solution

*Compact Solution*

Actually, I implemented this solution /after/ figuring out the Python solution. When working in Python there is a pythonic and an unpythonic way to solve a problem. Python programmers generally favor list comprehension operations over looping through arrays, so the use of for loops is discouraged. Javascript also has quite powerful array functions, so the compact solution is also a one-liner, but comparing the two versions it is clear that the result is not as easy to read as its Python alternative.

#+NAME: Compact solution
#+BEGIN_SRC js :result raw :noweb yes
<<js-testcase>> 

function challenge_solution(lines) {
    var n_temp = lines[0].split(' ');
    var n = parseInt(n_temp[0]);
    var k = parseInt(n_temp[1]);
    var a = lines[1].split(" ");;
    return left_rotate(n, k, a).join(" ");
}
function left_rotate(n, k, a) {
    return a.slice(k).concat(a.slice(0,k));
}

var folder = "./testcases/arrays-left-rotation";

return tc.results(
    tc.suite(
        tc.list(folder), challenge_solution
    )
);
#+END_SRC

#+RESULTS: Compact solution
| Test case | Success | Runtime |
|         1 | true    | 0 msec  |
|         2 | true    | 0 msec  |
|         3 | true    | 0 msec  |
|         4 | true    | 0 msec  |
|         5 | true    | 0 msec  |
|         6 | true    | 1 msec  |
|         7 | true    | 1 msec  |
|         8 | true    | 2 msec  |
|         9 | true    | 13 msec |
|        10 | true    | 22 msec |

**** Python

Python list comprehension operators are extremely powerful, so this solution is just a one-liner. The underlying approach is the same, merging two sublists from the original array, the first from the /*k*/ element until the last (/*n-1*/) element, and the second from the first element until the /*(k-1)*/ element. Notice how cleanly the code follows the algorithm.

#+BEGIN_SRC python :noweb yes
<<py-testcase>>

tc = TestCase("./testcases/arrays-left-rotation");

def left_rotate(n, k, a):
    return a[k:n] + a[0:k]

def challenge_solution(lines):
    n, k = [int(x) for x in lines[0].split(" ")]
    a = [int(x) for x in lines[1].split(" ")]
    return left_rotate(n, k, a)

return tc.results(tc.suite(tc.list(), challenge_solution))
#+END_SRC

#+RESULTS:
| Test case | Success | Runtime |
|         1 | True    | 0 msec  |
|         2 | True    | 0 msec  |
|         3 | True    | 0 msec  |
|         4 | True    | 0 msec  |
|         5 | True    | 0 msec  |
|         6 | True    | 6 msec  |
|         7 | True    | 7 msec  |
|         8 | True    | 1 msec  |
|         9 | True    | 58 msec |
|        10 | True    | 68 msec |

** Stacks: Balanced Brackets
*** Problem Definition

A bracket is considered to be any one of the following characters: =(=, =)=, ={=, =}=, =[=, or =]=.

Two brackets are considered to be a matched pair if the an opening bracket (i.e., =(=, =[=, or ={=) occurs to the left of a closing bracket (i.e., =)=, =]=, or =}=) of the exact same type. There are three types of matched pairs of brackets: =[]=, ={}=, and =()=.

A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, ={[(])}= is not balanced because the contents in between ={= and =}= are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, =(=, and the pair of parentheses encloses a single, unbalanced closing square bracket, =]=.

By this logic, we say a sequence of brackets is considered to be balanced if the following conditions are met:

- It contains no unmatched brackets.
- The subset of brackets enclosed within the confines of a matched pair of brackets is also a matched pair of brackets.

Given /*n*/  strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, print =YES= on a new line; otherwise, print =NO= on a new line.

*** Input Format

The first line contains a single integer, /*n*/, denoting the number of strings. 
Each line /*i*/ of the /*n*/ subsequent lines consists of a single string, /*s*/, denoting a sequence of brackets.

*** Constraints

- 1 \le /*n*/ \le 10^3
- 1 \le /*length(s)*/ \le 10^3, where  is the length of the sequence.
- Each character in the sequence will be a bracket (i.e., ={=, =}=, =(=, =)=, =[=, and =]=).

*** Output Format

For each string, print whether or not the string of brackets is balanced on a new line. If the brackets are balanced, print =YES=; otherwise, print =NO=.

**** Sample Input

#+BEGIN_SRC sh :eval never
3
{[()]}
{[(])}
{{[[(())]]}}
#+END_SRC

**** Sample Output

#+BEGIN_SRC sh :eval never
YES
NO
YES
#+END_SRC

*** Explanation

The string ={[()]}= meets both criteria for being a balanced string, so we print =YES= on a new line.
The string ={[(])}= is not balanced, because the brackets enclosed by the matched pairs =[(]= and =(])= are not balanced. Thus, we print =NO= on a new line.
The string ={{[[(())]]}}= meets both criteria for being a balanced string, so we print =YES= on a new line.

*** Solutions
